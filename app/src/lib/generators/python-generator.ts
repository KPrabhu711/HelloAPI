import { ApiSpec } from '../types';

export function generatePythonClient(spec: ApiSpec): string {
    const authImport = spec.auth.type !== 'none' ? '\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n' : '';
    const lines: string[] = [];

    lines.push(`"""
${spec.title} — Python Starter Client
Auto-generated by HelloAPI
"""

import requests
import time${authImport}

class ${sanitizeClassName(spec.title)}Client:
    """Auto-generated API client for ${spec.title}."""

    def __init__(self, base_url: str = "${spec.baseUrl}", ${getAuthParam(spec)}):
        self.base_url = base_url.rstrip("/")
        self.session = requests.Session()
        self.session.headers.update(${getHeadersDict(spec)})
        self.max_retries = 3
        self.backoff_factor = 1

    def _request(self, method: str, path: str, **kwargs) -> requests.Response:
        """Make a request with automatic retry and backoff."""
        url = f"{self.base_url}{path}"
        for attempt in range(self.max_retries):
            try:
                response = self.session.request(method, url, **kwargs)
                if response.status_code == 429:
                    wait = int(response.headers.get("Retry-After", self.backoff_factor * (2 ** attempt)))
                    print(f"Rate limited. Waiting {wait}s before retry...")
                    time.sleep(wait)
                    continue
                response.raise_for_status()
                return response
            except requests.exceptions.ConnectionError:
                if attempt < self.max_retries - 1:
                    time.sleep(self.backoff_factor * (2 ** attempt))
                    continue
                raise
        return response  # type: ignore
`);

    // Generate methods for each endpoint
    for (const ep of spec.endpoints) {
        const methodName = sanitizeMethodName(ep.operationId || `${ep.method.toLowerCase()}_${ep.path}`);
        const pathParams = ep.parameters.filter(p => p.in === 'path');
        const queryParams = ep.parameters.filter(p => p.in === 'query');
        const hasBody = !!ep.requestBody;

        const params: string[] = ['self'];
        for (const p of pathParams) {
            params.push(`${sanitizePythonVar(p.name)}: str`);
        }
        if (queryParams.length > 0) {
            for (const p of queryParams) {
                const defVal = p.required ? '' : ' = None';
                params.push(`${sanitizePythonVar(p.name)}: str${defVal}`);
            }
        }
        if (hasBody) {
            params.push('data: dict = None');
        }

        let pathStr = ep.path;
        for (const p of pathParams) {
            pathStr = pathStr.replace(`{${p.name}}`, `{${sanitizePythonVar(p.name)}}`);
        }

        lines.push(`
    def ${methodName}(${params.join(', ')}):
        """${ep.summary || `${ep.method} ${ep.path}`}"""
        path = f"${pathStr}"`);

        if (queryParams.length > 0) {
            lines.push(`        params = {${queryParams.map(p => `"${p.name}": ${sanitizePythonVar(p.name)}`).join(', ')}}`);
            if (hasBody) {
                lines.push(`        return self._request("${ep.method}", path, params=params, json=data)`);
            } else {
                lines.push(`        return self._request("${ep.method}", path, params=params)`);
            }
        } else if (hasBody) {
            lines.push(`        return self._request("${ep.method}", path, json=data)`);
        } else {
            lines.push(`        return self._request("${ep.method}", path)`);
        }
    }

    // Usage example
    lines.push(`

# ─── Usage Example ───

if __name__ == "__main__":
    client = ${sanitizeClassName(spec.title)}Client()
`);

    const firstGet = spec.endpoints.find(e => e.method === 'GET' && !e.path.includes('{'));
    if (firstGet) {
        const name = sanitizeMethodName(firstGet.operationId || `${firstGet.method.toLowerCase()}_${firstGet.path}`);
        lines.push(`    response = client.${name}()`);
        lines.push(`    print(response.json())`);
    } else if (spec.endpoints.length > 0) {
        lines.push(`    # Add your first API call here`);
    }

    return lines.join('\n');
}

// ─── Helpers ───

function sanitizeClassName(name: string): string {
    return name.replace(/[^a-zA-Z0-9]/g, '').replace(/^[0-9]/, '_') || 'Api';
}

function sanitizeMethodName(name: string): string {
    return name
        .replace(/[{}\/\-.]/g, '_')
        .replace(/_{2,}/g, '_')
        .replace(/^_|_$/g, '')
        .toLowerCase();
}

function sanitizePythonVar(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
}

function getAuthParam(spec: ApiSpec): string {
    if (spec.auth.type === 'bearer') return 'token: str = os.getenv("API_TOKEN", "")';
    if (spec.auth.type === 'apiKey') return 'api_key: str = os.getenv("API_KEY", "")';
    if (spec.auth.type === 'basic') return 'username: str = os.getenv("API_USERNAME", ""), password: str = os.getenv("API_PASSWORD", "")';
    return '';
}

function getHeadersDict(spec: ApiSpec): string {
    if (spec.auth.type === 'bearer') return '{"Authorization": f"Bearer {token}"}';
    if (spec.auth.type === 'apiKey' && spec.auth.headerName) return `{"${spec.auth.headerName}": api_key}`;
    return '{}';
}
